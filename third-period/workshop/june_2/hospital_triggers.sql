DROP TABLE IF EXISTS treatment CASCADE;

DROP TABLE IF EXISTS appointment CASCADE;

DROP TABLE IF EXISTS patient_audit_log CASCADE; -- Added for trigger example

DROP TABLE IF EXISTS patient CASCADE;

DROP TABLE IF EXISTS doctor CASCADE;

DROP TABLE IF EXISTS specialty CASCADE;

CREATE TABLE specialty (
    spe_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE doctor (
    doc_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    surname VARCHAR(255) NOT NULL,
    phone VARCHAR(20) NOT NULL,
    email VARCHAR(255),
    spe_id INT NOT NULL REFERENCES specialty (spe_id)
);

CREATE TABLE patient (
    pat_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    surname VARCHAR(255) NOT NULL,
    birth_date DATE NOT NULL,
    gender CHAR(1),
    phone VARCHAR(20) NOT NULL,
    address VARCHAR(255) NOT NULL
);

CREATE TABLE appointment (
    app_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    date DATE NOT NULL,
    time TIME NOT NULL,
    reason VARCHAR(255) NOT NULL,
    pat_id INTEGER NOT NULL REFERENCES patient (pat_id),
    doc_id INTEGER NOT NULL REFERENCES doctor (doc_id)
);

CREATE TABLE treatment (
    tre_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    description VARCHAR(500) NOT NULL,
    start_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    end_date TIMESTAMP DEFAULT NULL,
    app_id INT NOT NULL REFERENCES appointment (app_id)
);

-- Tabla para el registro de auditoría de pacientes (Caso 3 del disparador)
CREATE TABLE patient_audit_log (
    log_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pat_id INT, -- Puede ser NULL si la clave original no existía
    full_name VARCHAR(511), -- name + surname del paciente eliminado
    deletion_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);


-- =============================================================================
-- DISPARADORES (TRIGGERS)
-- =============================================================================

-- CASO 1: Validar que la fecha de fin de un tratamiento no sea anterior a la de inicio.
-- PROBLEMA: Se necesita mantener la consistencia lógica en los tratamientos, asegurando que la fecha de fin no sea previa a la fecha de inicio.
-- SOLUCIÓN: Se implementa un disparador BEFORE INSERT OR UPDATE en la tabla 'treatment'
-- que ejecuta una función. Esta función verifica si la 'end_date' es menor que la 'start_date'
-- y, si es así, aborta la operación levantando una excepción.

CREATE OR REPLACE FUNCTION check_treatment_end_date()
RETURNS TRIGGER AS $$
BEGIN
    -- Verificar si end_date está especificada y es anterior a start_date
    IF NEW.end_date IS NOT NULL AND NEW.end_date < NEW.start_date THEN
        RAISE EXCEPTION 'Error: La fecha de fin del tratamiento no puede ser anterior a la fecha de inicio.';
    END IF;
    -- Permite la operación si la validación pasa o si end_date es NULL
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_treatment_end_date
BEFORE INSERT OR UPDATE ON treatment
FOR EACH ROW
EXECUTE FUNCTION check_treatment_end_date();


-- CASO 2: Prevenir la sobreposición de citas para el mismo doctor a la misma hora.
-- PROBLEMA: Un doctor no puede atender a dos pacientes al mismo tiempo. Se debe evitar agendar citas duplicadas para un mismo doctor en la misma fecha y hora.
-- SOLUCIÓN: Se crea un disparador BEFORE INSERT OR UPDATE en la tabla 'appointment'.
-- La función asociada consulta si ya existe otra cita (excluyendo la actual en caso de UPDATE)
-- para el mismo doctor, en la misma fecha y hora. Si encuentra un conflicto, cancela la inserción o actualización.

CREATE OR REPLACE FUNCTION check_doctor_appointment_overlap()
RETURNS TRIGGER AS $$
BEGIN
    -- Verificar si ya existe una cita para este doctor en esta fecha y hora,
    -- excluyendo la fila actual en caso de una actualización.
    IF EXISTS (
        SELECT 1
        FROM appointment
        WHERE doc_id = NEW.doc_id
          AND date = NEW.date
          AND time = NEW.time
          AND app_id <> NEW.app_id -- Importante para UPDATES: Ignorar la fila que se está actualizando
    ) THEN
        RAISE EXCEPTION 'Error: El doctor ya tiene una cita programada para la fecha % a las %.', NEW.date, NEW.time;
    END IF;
    -- Permite la operación si no hay sobreposición
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_doctor_appointment_overlap
BEFORE INSERT OR UPDATE ON appointment
FOR EACH ROW
EXECUTE FUNCTION check_doctor_appointment_overlap();


-- CASO 3: Registrar la eliminación de pacientes en una tabla de auditoría.
-- PROBLEMA: Se necesita un registro histórico de los pacientes que son eliminados del sistema
-- por razones de auditoría o cumplimiento, manteniendo una copia básica de la información antes de la eliminación.
-- SOLUCIÓN: Se define un disparador AFTER DELETE en la tabla 'patient'.
-- La función asociada se ejecuta después de cada eliminación de fila en 'patient'.
-- Esta función inserta el ID y el nombre completo del paciente eliminado (disponible en la variable OLD)
-- junto con una marca de tiempo en la tabla 'patient_audit_log'.

CREATE OR REPLACE FUNCTION log_patient_deletion()
RETURNS TRIGGER AS $$
BEGIN
    -- Insertar información del paciente eliminado en la tabla de auditoría
    INSERT INTO patient_audit_log (pat_id, full_name)
    VALUES (OLD.pat_id, OLD.name || ' ' || OLD.surname); -- OLD contiene los datos de la fila eliminada
    -- En un trigger AFTER DELETE, el valor de retorno no afecta la operación,
    -- pero por convención se retorna OLD o NEW (si estuviera disponible).
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_log_patient_deletion
AFTER DELETE ON patient
FOR EACH ROW
EXECUTE FUNCTION log_patient_deletion();


-- =============================================================================
-- INSERCIÓN DE DATOS DE EJEMPLO
-- =============================================================================

INSERT INTO
    specialty (name)
VALUES
    ('Cardiologia'),
    ('Pediatria'),
    ('Dermatologia'),
    ('Neurologia'),
    ('Oncologia'),
    ('Practica General');


INSERT INTO
    doctor (name, surname, phone, email, spe_id)
VALUES
    (
        'Juan',
        'Perez',
        '555-0101',
        'juan.perez@hospital.com',
        1
    ), -- Cardiologia
    (
        'Maria',
        'Garcia',
        '555-0102',
        'maria.garcia@hospital.com',
        2
    ), -- Pediatria
    (
        'Luis',
        'Rodriguez',
        '555-0103',
        'luis.rodriguez@hospital.com',
        3
    ), -- Dermatologia
    (
        'Ana',
        'Martinez',
        '555-0104',
        'ana.martinez@hospital.com',
        4
    ), -- Neurologia
    (
        'Carlos',
        'Lopez',
        '555-0105',
        'carlos.lopez@hospital.com',
        5
    ), -- Oncologia
    (
        'Elena',
        'Fernandez',
        '555-0106',
        'elena.fernandez@hospital.com',
        6
    );


INSERT INTO
    patient (name, surname, birth_date, gender, phone, address)
VALUES
    (
        'Pedro',
        'Gomez',
        '1990-05-10',
        'M',
        '555-1111',
        '123 Main St, Anytown'
    ),
    (
        'Sofia',
        'Diaz',
        '2015-11-20',
        'F',
        '555-2222',
        '456 Oak Ave, Anytown'
    ),
    (
        'Jorge',
        'Ruiz',
        '1975-03-15',
        'M',
        '555-3333',
        '789 Pine Ln, Anytown'
    ),
    (
        'Laura',
        'Sanchez',
        '1988-07-01',
        'F',
        '555-4444',
        '101 Maple Dr, Anytown'
    ),
    (
        'Miguel',
        'Torres',
        '1960-09-30',
        'M',
        '555-5555',
        '202 Birch Blvd, Anytown'
    ),
    (
        'Isabella',
        'Castro',
        '2000-01-25',
        'F',
        '555-6666',
        '303 Cedar Ct, Anytown'
    );

INSERT INTO
    appointment (date, time, reason, pat_id, doc_id)
VALUES
    ('2023-10-26', '10:00:00', 'Annual Checkup', 1, 1), -- Pedro Gomez (Pat 1) -> Juan Perez (Doc 1)
    ('2023-10-26', '11:00:00', 'Vaccination', 2, 2), -- Sofia Diaz (Pat 2) -> Maria Garcia (Doc 2)
    (
        '2023-10-27',
        '09:30:00',
        'Chest Pain Consultation',
        3,
        1
    ), -- Jorge Ruiz (Pat 3) -> Juan Perez (Doc 1)
    (
        '2023-10-27',
        '14:00:00',
        'Skin Rash Evaluation',
        4,
        3
    ), -- Laura Sanchez (Pat 4) -> Luis Rodriguez (Doc 3)
    (
        '2023-10-28',
        '10:30:00',
        'Chronic Headache',
        5,
        4
    ), -- Miguel Torres (Pat 5) -> Ana Martinez (Doc 4)
    ('2023-10-28', '15:00:00', 'First Visit', 6, 6);

INSERT INTO
    treatment (description, app_id)
VALUES
    ('Se recomienda dieta y ejercicio.', 1),
    ('Administración de vacuna antigripal.', 2),
    ('Se ordenaron ECG y análisis de sangre.', 3),
    ('Se prescribió crema tópica.', 4),
    ('Se programó resonancia magnética.', 5),
    ('Consejos generales de salud.', 6);

-- Nota: Para probar los triggers, tu puedes ejecutar las siguientes sentencias SQL:
-- - INSERT INTO treatment (description, start_date, end_date, app_id) VALUES ('Invalid dates', '2023-12-01', '2023-11-30', 1); -- Should trigger an error (Case 1)
-- - INSERT INTO appointment (date, time, reason, pat_id, doc_id) VALUES ('2023-10-26', '10:00:00', 'Duplicate check', 2, 1); -- Should trigger an error (Case 2)

-- Should insert a row into patient_audit_log (Case 3)
-- BEGIN;
--   DELETE FROM treatment WHERE app_id = 1;
--   DELETE FROM appointment WHERE pat_id = 1;
--   DELETE FROM patient WHERE pat_id = 1;
--   SELECT * FROM patient_audit_log;
--   SELECT * FROM patient;
-- ROLLBACK;
